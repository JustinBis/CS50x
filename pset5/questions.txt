0.  It's the longest word in the dictionary. It's also a silly word to have in a dictionary at all, but hey, it sets a limit I guess.
1.  It tracks a program's resource usage, such as its running time, memory usage, etc.
2.  The struct has 16 members, two of which are structs themselves.
3.  Passing the struct by reference means that there doesn't have to be any additional memory usage or time spent from copying the struct, so the stats are better. 
4.  Ready for a precise yet concise blast of analysis? Good.
    So the loop initilizes the variable c to the first character using fgetc, and continues looping until fgetc returns an EOF (end of file) marker. At the end of each iteration, c is reassigned using fgetc, which will assign the next character.
    Inside the loop, we first check if the character is alphabetical or an apostrophe. If it is, we add that character to the current word (an array of chars) at the current index (which begins at zero, as set before the loop).
        We increment the index, and then check if the word has become too long. If it has, we skip the rest of the characters by creating a loop that continues calling fgetc until it reaches a non-alphabetic character that signifies the end of the word. Because the current word is finished, we set the index back to 0, then move on to the next iteration.
    If it turns out that the word contained a number, we skip the word in the same way as before.
    Otherwise, if c isn't an alphabetic or numeric character, we know we have found the end of a word, so we add a null character (\0) to the current index to mark then end of the word. We then update the words counter because we have added a new word.
    (Turns out that was less concise and more precise than I had planned. Sorry!)
5.  Using fscanf relies on the input text to be properly formatted, wouldn't allow us to make sure that the scanned string isn't too long to be a word, and would make it more difficult and time consuming to ignore words with numbers like we do in this program.
6.  It only makes sense to declare the values as constants, because we shouldn't need to change any values if we are checking words or loading something into memory. Declaring them as constant prevents any accidental changes.
7.  My data structure of choice was the beast, my main man, the big kahuna: the trie. Inside each of the nodes in my trie is an array of 27 pointers to more nodes (one for each letter plus an extra for apostrophes), as well as a boolean value "isWord" that is set to true when it's containing node represents the last letter in a word that is in the dictionary.
    The trie is suprisingly simple, requiring only an array of pointers and a boolean value to work. This simplicity makes it easy to unload as well, which is done by calling a recursive function that frees each node backwards, starting with the deepest arrays and working its way back.
8.  Not slow at all! I was only 0.01 off of the staff's solution! I'd say that's not bad for my first working implementation! I'm now at the same speed as the saff, and I'm still looking for that last bit of optimization to beat your code!
9.  I've made minor tweaks, took out unnecessary checks and attempted different code organiziation, but my program has always run at about the same speed. Everything I've done has only sped it up by abound 0.01
10. The main bottlenecks I see the slow time spent loading the trie and the time spent unloading it. Because it has to be flexible and work for numerous dictionaries, there are hundreds of unused pointers and a lot of time is spent creating them, checking over them, and skipping past them during the deallocation. If I was able to use a precomputed dictionary, my code could be sped up tremendously.
